<section class="kjf-rxjs-simple">
  <section>
    <br />
    <hr />
    <div class="question-title">在前端，我们通常有这么一些方式来<span class="kjf-bolder-font">
    处理异步 </span>的东西：
    </div>
    <p class="kjf-tab-2">
      回调 ---- 事件 ---- Promise ---- <a href="https://www.liaoxuefeng.com/wiki/1022910821149312/1023024381818112" target="_blank">
      Generator </a> <br />
    </p>
    <p class="kjf-tab-4">
      回调、事件或者类似订阅发布 ===> 适合处理<span class="kjf-bolder-font"> 分发 </span>的需求 <br />
      Promise和Generator ===> 适合处理<span class="kjf-bolder-font"> 流程性质 </span>的需求 <br />
    </p>
  </section>

  <section>
    <br />
    <hr />
    <div class="question-title">
      <a href="https://rxjs-dev.firebaseapp.com/" target="_blank">
        <span class="kjf-inline-pointer">什么是rxjs:</span>
      </a>
    </div>
    <p class="kjf-tab-2">
      我们都知道 JS 是什么，那么什么是 Rx 呢？
    </p>
    <p class="kjf-tab-4">
      Rx 是 Reactive Extension（也叫 ReactiveX）的简称，指的是实践响应式编程的一套工具<br />
      Rx 官网首页的介绍是<span class="kjf-purple-font">一套通过可监听流来做异步编程的 API</span>（An API for asynchronous programming with observable streams）。<br />
      Rx 最早是由微软开发的 LinQ 扩展出来的开源项目，之后由开源社区维护，有多种语言的实现，如 Java 的 RxJava，Python 的 RxPY 等，而 RxJS 就是 Rx 的 JavaScript 语言实现。
    </p>
  </section>

  <section>
    <br />
    <hr />
    RxJS 引入了两种重要的编程思想：函数式编程和响应式编程。<br />
    实际上Rx 组合了观察者模式（Observer pattern ）、迭代器模式（Iterator pattern）和函数式编程

    <div>
      <p class="kjf-tab-2">
        <span class="kjf-orange-font">观察者模式（Observer pattern ）</span>
      </p>
      <p class="kjf-tab-4 kjf-purple-font">
        特点：渐进式使用数据的，数据是推送（push）过来的
      </p>
      <p class="kjf-tab-4">
        观察者模式，我们其实比较熟悉了。订阅者订阅后，发布者吐出数据时，订阅者会响应式进行处理。
      </p>
      <p class="kjf-tab-4">
        比如各种 DOM 事件的监听，也是观察者模式的一种实践。核心就是发布者发布事件，观察者选择时机去订阅（subscribe）事件。
      </p>
    </div>

    <div>
      <p class="kjf-tab-2">
        <span class="kjf-orange-font">迭代器模式（Iterator pattern）</span>
      </p>
      <p class="kjf-tab-4 kjf-purple-font">
        特点：渐进式使用数据的，数据是自己去拉取（pull）的 <br />
      </p>
      <p class="kjf-tab-4">
        ！！！【Rx 中的数据是 Observable 推送的，观察者不需要主动去拉取。】
      </p>
      <p class="kjf-tab-4">
        响应式编程抽象出了流这个概念，提高了代码的抽象级别，不用去关心大量的实现细节，而专注于对数据流的操作。
      </p>
    </div>

    <div>
      <p class="kjf-tab-2">
        <span class="kjf-orange-font">函数式编程</span>
      </p>
      <p class="kjf-tab-4">
        函数式编程（Functional Programming，简称 FP）是一种编程范式，强调<span class="kjf-purple-font">使用函数来思考问题、编写代码</span>
        <br />对函数的使用有一些特殊要求：
      </p>

      <div>
        <p class="kjf-tab-6">（1）声明式（Declarative）</p>
        <p class="kjf-tab-10">让开发者只需要表达”想要做什么”，而不需要表达“怎么去做”。</p>
      </div>

      <div>
        <p class="kjf-tab-6">（2）纯函数（Pure Function）</p>
        <div>
          <p class="kjf-tab-10">
            指的是执行结果由输入参数决定，参数相同时结果相同，不受其他数据影响，并且不会带来副作用（Side Effect）的函数。 <br />
            <span class="kjf-orange-font">副作用</span>指的是 <span class="kjf-purple-font">函数做了和本身运算返回值没有关系的事情</span>
          </p>
          <p class="kjf-tab-12">如修改外部变量或传入的参数对象，甚至是执行 console.log 都算是 Side Effect。</p>
          <p class="kjf-tab-12">前端中常见的副作用有发送 http 请求、操作 DOM、调用 alert 或者 confirm 函数等。</p>
        </div>
        <p class="kjf-tab-10">满足纯函数的特性也叫做引用透明度（Referential Transparency）。</p>
      </div>

      <div>
        <p class="kjf-tab-6">（3）数据不可变性（Immutability）</p>
        <p class="kjf-tab-10">指这个数据一旦产生，它的值就永远不会变。</p>
      </div>
    </div>

    <div>
      <p class="kjf-tab-2">
        <span class="kjf-orange-font">响应式编程</span>
      </p>
      <p class="kjf-tab-4">
        中文维基上说响应式编程（Reactive Programming）是一种面向数据流（stream）和变化传播的编程范式。
      </p>
      <p class="kjf-tab-4">
        响应式编程抽象出了流这个概念，提高了代码的抽象级别，不用去关心大量的实现细节，而专注于对数据流的操作。
      </p>
    </div>
  </section>

  <section>
    <br />
    <hr />
    事件的 <a href="https://www.lodashjs.com/" target="_blank">lodash</a><br />
    <p class="kjf-tab-2">
      从事件到流，它被称为lodash for events，倒不如说是<span class="kjf-bolder-font"> lodash for stream </span>更贴切<br />
      我们可以把
      <span class="kjf-bolder-font"> 用户操作 </span>
      <span class="kjf-bolder-font"> 网络响应 </span>
      <span class="kjf-bolder-font"> 定时器 </span>
      <span class="kjf-bolder-font"> Worker </span>
      等等一切输入都当做数据流来处理<br />
    </p>
  </section>

  <code>
    <pre>

    <h5 class="kjf-inline-pointer" (click)="toChildComponent('observable')">Observable 可观察序列，只出不进</h5>

    <h5 class="kjf-inline-pointer" (click)="toChildComponent('observable')">Observer 观察者，只进不出</h5>
      是一个有三个方法的对象 &#123;
        next: 当 Observable 发出新的值时被调用，接收这个值作为参数
        complete：当 Observable 完结，没有更多数据时被调用。complete 之后，next 方法无效
        error：当 Observable 内部发生错误时被调用，之后不会调用 complete，next 方法无效
      &#125;

    Subject 可出可进的可观察序列，可作为观察者

    ReplaySubject 带回放

    Subscription 订阅关系----订阅之后形成的一个订阅关系，可以用于取消订阅
    </pre>
  </code>

  <code>
    <pre>
    <span>
    0. RxJS 的 import 路径有以下 5 种：
    </span>
      (1) 创建 Observable 的方法、types、schedulers 和一些工具方法
          import [
            Observable,
            Subject,
            asapScheduler,
            pipe, of, from, interval, merge, fromEvent, SubscriptionLike, PartialObserver
          ] from 'rxjs';

      (2) 操作符 operators
          import [ map, filter, scan ] from 'rxjs/operators';

      (3) webSocket
          import [ webSocket ] from 'rxjs/webSocket';

      (4) ajax
          import [ ajax ] from 'rxjs/ajax';

      (5) 测试
          import [ TestScheduler ] from 'rxjs/testing';
    </pre>
  </code>
  <br /> <span class="kjf-tips-font">tips: </span>$ 符号结尾，是 RxJS 中的一种惯例 <br />
  <code>
    <pre>
    <span (click)="toChildComponent('create_date_stream')">
    1. RxJS提供了各种API来<h5 class="kjf-inline-pointer">创建数据流</h5>:
    </span>
      单值：of, empty, never
      多值：from
      定时：interval, timer
      从事件创建：fromEvent
      从Promise创建：fromPromise
      自定义创建：create
    </pre>
  </code>

  <code>
    <pre>
    <span (click)="toChildComponent('rxjs_demo')">
    2. 数据流是一种可观察的序列，可以被订阅
    </span>
    </pre>
  </code>

  <code>
    <pre>
    <span (click)="toChildComponent('rxjs_demo')">
    3. 数据流也可以被用来做一些 <span class="kjf-bolder-font">转换操作</span>，比如：
    </span>
      改变数据形态：map, mapTo, pluck
      过滤一些值：filter, skip, first, last, take
      时间轴上的操作：delay, timeout, throttle, debounce, audit, bufferTime
      累加：reduce, scan
      异常处理：throw, catch, retry, finally
      条件执行：takeUntil, delayWhen, retryWhen, subscribeOn, ObserveOn
      转接：switch
    </pre>
  </code>

  <code>
    <pre>
    <span (click)="toChildComponent('muti_stream')">
    4. <span class="kjf-bolder-font">对若干个数据流进行<h5 class="kjf-inline-pointer">组合</h5></span>，比如：
    </span>
      concat，保持原来的序列顺序连接两个数据流
      merge，合并序列
      race，预设条件为其中一个数据流完成
      forkJoin，预设条件为所有数据流都完成
      zip，取各来源数据流最后一个值合并为对象
      combineLatest，取各来源数据流最后一个值合并为数组
    </pre>
  </code>

  <code>
    <pre>
    <span (click)="toChildComponent('usual_operator')">
    5. <h5 class="kjf-inline-pointer"><span class="kjf-bolder-font">常见操作符</span></h5>，比如：
    </span>
      retry – 失败时重试
      repeat – 成功时重试
      delay – 延迟
      toArray – 收集为数组
      debounceTime – 防抖
      switchMap – 切换成另一个流
    </pre>
  </code>

  <code>
    <pre>
    <span (click)="toChildComponent('rxjs_demo')">
    6. <span class="kjf-bolder-font">operator 规律：</span>
    </span>
      当你掌握了一些基本操作符之后，就可以让自己的操作符知识翻倍了。

      这是因为 RxJS 中的很多操作符都遵循着同样的命名模式。比如：

      <span class="kjf-bolder-font">xxxWhen – 满足条件时 xxx</span>
        它接受一个 Observable 型参数作为条件流，一旦这个条件流中出现任意数据，则进行 xxx 操作。
        如 retryWhen(notifier$)，其中的 notifier$ 就是一个条件流。
        当输入流出现异常时，就会开始等待 notifier$ 流中出现数据，
        一旦出现了任何数据（不管是什么值），就会开始执行重试逻辑。

      <span class="kjf-bolder-font">xxxCount – 拿到 n 个数据项时 xxx</span>
        它接受一个数字型参数作为阈值，一旦从输入流中取到了 n 个数据，则进行 xxx 操作。
        如 bufferCount(3) 表示每拿到 3 个数据就进行一次 buffer 操作。
        这个操作可以看做是 xxxWhen 的语法糖。

      <span class="kjf-bolder-font">xxxTime – 超时后 xxx</span>
        它接受一个超时时间作为参数，从输入流中取数据，一旦到达超时时间，则执行 xxx 操作。
        比如前面讲过的 debounceTime 其实遵循的就是这种模式。
        这个操作可以看做 xxxWhen 的语法糖。

      <span class="kjf-bolder-font">xxxTo – 用立即量代替 Lambda 表达式</span>
        它接受一个立即量作为参数，相当于 xxx(()=&gt;value))。
        比如 mapTo('a') 其实是 map(()=&gt;'a') 的语法糖，也就是说无论输入流中给出的值是什么，
        我往输出流中放入的都是这个固定的值。
    </pre>
  </code>

  <code>
    <pre>
    <span (click)="toChildComponent('rxjs_demo')">
    7. <span class="kjf-bolder-font">坑与最佳实践：</span>
    </span>
      <span class="kjf-bolder-font">取消订阅</span>
        subscribe 之后，你的回调函数就被别人引用了，因此如果不撤销对这个回调函数的引用，那么与它相
        关的内存就永远不会释放，同时，它仍然会在流中有数据过来时被调用，可能会导致奇
        怪的 console.log 等意外行为。
        因此，必须找到某个时机撤销对这个回调函数的引用。但其实不一定需要那么麻烦。
        解除对回调函数的引用有两种时机，
          一种是这个流完成（complete，包括正常结束和异常结束）了，
            当流完成时，会自动解除全部订阅回调，而所有的有限流都是会自动完成的。
            只有无尽流才需要特别处理，也就是订阅方要主动取消订阅。
          一种是订阅方主动取消。
        当调用 Observable 的 subscribe 方法时，会返回一个 Subscription 类型的引用，它实际上是一
        个订阅凭证。把它保存下来，等恰当的时机调用它的 unsubscribe 方法就可以取消订阅了。
          比如在 Angular 中，如果你订阅了无尽流，那么就需要把订阅凭证保存在私有变量里，并且
          在 ngOnDestroy 回调中调用它的 unsubscribe 方法。

      <span class="kjf-bolder-font">类型检查</span>
        只要有可能，请尽量使用 TypeScript 来书写 RxJS 程序。
        由于大量 operator 都会改变流中的数据类型，因此如果靠人力来追踪数据类型的变化既繁琐又容易出错。
        TypeScript 的类型检查可以给你提供很大的帮助，既省心又安全，而且这两个都是微软家的，搭配使用，风味更佳。

      <span class="kjf-bolder-font">代码风格式</span>
        如同所有 FP 程序一样，ReactiveX 的代码也应该由一系列小的、单一职责的、无副作用的函数组成。
        虽然 JavaScript 无法像 Java 中那样对 Lambda 表达式的副作用做出编译期限制，但是仍然要遵循同
        样的原则，坚持无副作用和数据不变性。
    </pre>
  </code>

</section>
